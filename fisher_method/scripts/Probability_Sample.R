#input requirements are observed dataset as matrix with columns as genotypes 
# colnames as clone names and symmetry of matrix with NAs. stringsAsFactors=False! 

#input epsilon is small value to regularize 0 counts. 
# eplison = 1/M

#requires Build_Probability_Matrix() to be sourced


Probability_Sample<-function(Genes_by_clone_dataframe){
#library(plyr)

  #first step is to generate a matrix of marginal probabilities using the build_probability_matrix function
  Probability_Matrix<-Build_Probability_Matrix(Genes_by_clone_dataframe)

#sample vectors of appropriate sizes (based on original data set) and missing data can be filled with NA's. 
      #empty dataframe and replace with NA
all.genes<-list() #loop will fill all.genes with all genes in dataset
  for (h in names(Genes_by_clone_dataframe)){
  list<-na.omit(Genes_by_clone_dataframe[, h], stringsAsFactors=FALSE) 
  all.genes<-append(all.genes, list)
    } 
  df_to_sample<-data.frame(matrix(unlist(all.genes),nrow=length(all.genes), byrow=T), stringsAsFactors=FALSE)
  df_to_sample<-df_to_sample[!duplicated(df_to_sample), ]
  col_names<- names(Genes_by_clone_dataframe)
  Sampled_dataframe<- data.frame(matrix(NA, nrow=length(df_to_sample), ncol=length(col_names)+1))
  Sampled_dataframe[,1]<- df_to_sample
  colnames(Sampled_dataframe)[2:ncol(Sampled_dataframe)]<- col_names
  colnames(Sampled_dataframe)[1]<-"sigma"
  Sampled_dataframe<-merge(Probability_Matrix, Sampled_dataframe, by="sigma", all=TRUE)
  # up to this point I set up an empty matrix for sampling and a probability vector
  
#repeat loop to ensure all genotypes get at least 2 genes
repeat {
for (i in 1:nrow(Sampled_dataframe)){
    for(j in 4:ncol(Sampled_dataframe)){
    Sampled_dataframe[i,j]<- rbinom(1, 1, Sampled_dataframe[i,3]) 
  }} # binomial sampling to fill dataframe 
LessThanTwo<-FALSE
for (p in 4:ncol(Sampled_dataframe)){
  if (sum(Sampled_dataframe[,p])<2){
    LessThanTwo<-TRUE
  }
}
  if(!LessThanTwo) break
}
  for (k in 4:ncol(Sampled_dataframe)){
    for (l in 1:nrow(Sampled_dataframe)){
      if (Sampled_dataframe[l,k]==1){
        Sampled_dataframe[l,k]<-Sampled_dataframe[l,1]
      }
    }
  } 
Sampled_dataframe[Sampled_dataframe==0]<-NA
Sampled_dataframe<-Sampled_dataframe[4:ncol(Sampled_dataframe)] 
# Sampled_dataframe complete
                             
# recount gene frequency     
all.genes<-list() #loop will fill all.genes with all genes in dataset
      for (h in 1:ncol(Sampled_dataframe)){
        list<-na.omit(Sampled_dataframe[, h], stringsAsFactors=FALSE) 
        all.genes<-append(all.genes, list)
      } 
      df<-data.frame(matrix(unlist(all.genes),nrow=length(all.genes), byrow=T), stringsAsFactors=FALSE)
      colnames(df)[1]<- "sigma2"
      gene_counts.2<-count(df, "sigma2")
      M<- sum(gene_counts.2[, 2])
      epsilon<-1/M
      N<- ncol(Genes_by_clone_dataframe)
      rm(df, all.genes)
      #conduct the normal Pairs analysis on the Sampled_dataframe 
      # code below taken directly from Construct_pairs function 
      all.data = data.frame(matrix(vector(), 0, 2,
                                   dimnames=list(c(), c("X1", "X2"))),
                            stringsAsFactors=F)
      
      for(i in 1:ncol(Sampled_dataframe)){
        #combn() generates all pairwise combinations
        list<-na.omit(Sampled_dataframe[, i])
        generatepairs<-combn(list, 2, simplify=FALSE, stringsAsFactors=FALSE)
        k=length(generatepairs)
        # convert the string generated by combn() to a dataframe 
        #with the 2 columns being the two genes in the pair
        pairs.to.df <-data.frame(matrix(unlist(generatepairs),nrow=k, byrow=T), stringsAsFactors=FALSE)
        all.data<-rbind(all.data, pairs.to.df, stringsAsFactors=FALSE)
      }
      ## take the above dataframe and add a column that 
      #contains both gene names using paste()
      # then use cbind() to add the new column to the dataframe

      All.Pairs<-Generate_Pairs_Dataframe(Genes_by_clone_dataframe)
      sigma1.sigma2<- paste(pmin(all.data$X1, all.data$X2), pmax(all.data$X1, all.data$X2))
      ## old way without alphebetizing# pairs<-paste(pairs.to.df[,1], pairs.to.df[,2])
      all.data<-cbind(sigma1.sigma2, all.data)
      pairscount<-count(all.data, "sigma1.sigma2")
      All.Pairs<-merge(All.Pairs, pairscount, by="sigma1.sigma2", all=TRUE)
      colnames(All.Pairs)[4]<-"sigma1.sigma2_Frequncy" 
      #columns 2 and 3 are sigma1 and sigma 2
      All.Pairs<-merge(All.Pairs, gene_counts.2, by="sigma2", all=TRUE) 
      sig1countdf<-All.Pairs[2:3]
      gene_counts.2->gene_counts.1
      colnames(gene_counts.1)<-c("sigma1", "sigma1.count")
      sig1countdf<-merge(sig1countdf, gene_counts.1, by="sigma1")
      sig1countdf<-sig1countdf[2:3]
      colnames(All.Pairs)[5]<-"sigma2_Frequency"
      #replace na values for non-occuring pairs with 0
      All.Pairs<-All.Pairs[, c(1, 5, 2, 4)]
      All.Pairs<- All.Pairs[All.Pairs$sigma1.sigma2!= "FALSE FALSE", ]
      All.Pairs<-merge(All.Pairs, sig1countdf, by="sigma1.sigma2", all=TRUE)
      All.Pairs<-All.Pairs[, c(2,3,1,4,5)]
      All.Pairs[is.na(All.Pairs)]<-0
      ######
      C0<- 1/(N*(1+epsilon))
      C <- 1/(N*(1+epsilon)^2)
      Msig1<- (All.Pairs[,5] + (N*epsilon))
      Msig2<- (All.Pairs[,2] + (N*epsilon))
      Po1<- Msig1 * C0
      Po2<- Msig2 * C0 
      Clones0.0<- N - ((All.Pairs[, 2]+ All.Pairs[, 5])-All.Pairs[, 4])
      
      All.Pairs$"Po1,o2(1,1)"<- C* ((((1+epsilon)^2)*All.Pairs[,4]) + 
                                      (((1+epsilon)*epsilon)* ((All.Pairs[,2]-All.Pairs[,4]) + (All.Pairs[,5]-All.Pairs[,4]))) +
                                      ((epsilon^2)*Clones0.0))
      
      All.Pairs$"Po1,o2(0,1)"<- C* ((All.Pairs[,2]-All.Pairs[,4])+((All.Pairs[,2]-All.Pairs[,4])*epsilon)+(Clones0.0*epsilon))
      All.Pairs$"Po1,o2(1,0)"<- C* ((All.Pairs[,5]-All.Pairs[,4])+((All.Pairs[,5]-All.Pairs[,4])*epsilon)+(Clones0.0*epsilon))
      All.Pairs$"Po1,o2(0,0)"<- C * Clones0.0
      All.Pairs$"Po1"<- Po1
      All.Pairs$"Po2"<- Po2
  All.Pairs<- All.Pairs[c(3,4,1,2,6,7,8,9,10,11)]
return(All.Pairs)
}
